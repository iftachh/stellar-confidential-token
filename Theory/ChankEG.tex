
\newcommand{\basefactor}{\MathAlgX{baseFcts}}
\newcommand{\Fshs}{{\sf Fsh}}

%%%%%%Twisted EG in the exponent
\newcommand{\tEgKG}{\MathAlgX{\widetilde{EgGen}}}
\newcommand{\tEgEnc}{\MathAlgX{\widetilde{EgEnc}}}
\newcommand{\tEgDec}{\MathAlgX{\widetilde{EgDec}}}

\newcommand{\tEgKeyGens}{{{\sf EgKG}}}
\newcommand{\rtEgKeyGen}{\cR_\tEgKeyGens}
\newcommand{\rtEgKeyGenDef}
{
	\set{(E,e))\colon e\cdot G= E}
}


\newcommand{\tEGEncs}{{{\sf EgEnc}}}
\newcommand{\rtEGEnc}{\cR_\tEGEncs}
\newcommand{\rtEGEncDef}
{
	\set{((H,E,\tA),(a,r))\colon \tEgEnc_{(H,E)}(a;r)= \tA}
}


\newcommand{\rtFshs}{{{\sf EgFsh}}}
\newcommand{\rtFsh}{\cR_\rtFshs}
\newcommand{\rtFshDef}
{
	\set{((\pk,\oA,b),(\oa,\orr))\colon \forall i\in (\ell)\colon  \tEgEnc_\pk(\oa_i;\orr_i)= \oA_i  
		\sland \oa_i \in (b)}
}


\newcommand{\rtEgEqs}{{{\sf EgEq}}}
\newcommand{\rtEgEq}{\cR_\rtEgEqs}
\newcommand{\rtEgEqDef}
{
	\set{(((H,E_0,E_1,\tA_0,\tA_1),(a,r_0,r_1))\colon \forall i\in \zo \colon \; \tEgEnc_{(H,E_i)}(a;r_i)= \tA_i}
}


\newcommand{\tEgRps}{{{\sf tEgRp}}}
\newcommand{\rtEgRp}{\cR_\tEgRps}
\newcommand{\rtEgRpDef}
{
	\set{((H,E,\tA,b),(a,r))\colon \tEgEnc_{(H,E)}(a;r)= \tA \sland a\in (b)}
}



%%%%Pedersen
\newcommand{\Ped}{\MathAlgX{Ped}}



\newcommand{\PedEncs}{{\sf PedEnc}}
\newcommand{\rPedEnc}{\cR_\PedEncs}

\newcommand{\rPedEncDef}
{
	\set{((H,A),(a,r))\colon \Ped_H(a;r)= A}
}





\section{The Chunk-ElGamal  Encryption Scheme}\label{sec:ChanksEG}
In this section, we define the  (almost) additive homomorphic encryption scheme based on ElGamal multiplicative  homomorphic encryption scheme.  \Inote{give citations}
The idea is to bootstrap the so-called   \textit{ElGamal in-the exponent}   additive homomorphic encryption/commitment  scheme,\footnote{It is called ElGamal ``in-the-exponent'' due to typical multiplicative group notation. Here use additive group notation, but keep the name for historical reason.}  which in turn is based on the  ElGamal multiplicative  homomorphic encryption scheme, that lacks efficient decryption algorithm, by splitting the plain text into small ``chunks''. That  is, we present a message $a\in Z_t$ as $\sum_{i \in (t/c)}   2^{i c} \cdot a_i$, where $c$, the chunk size, is  some integer  dividing $t$, and encrypt each of the $a_i$ using    additive homomorphic EG. To decry $\oA= (A_0,\ldots,A_{t/c})$, one  
\begin{enumerate}
	\item Decrypt   each $A_i$ to get $a_i  \cdot G$.
	\item Use brute force to find $a$.\footnote{One can use    processing to speed-up this part from $c$ group operations to $\sqrt{c}$  operations, or even \Inote{cite} to   $\sqrt[3]{c}$.}
	
	\item Reconstruct $a$.
\end{enumerate}
In \cref{sec:ChanksEG:tEG}, we formally define the  ElGamal in-the-exponent scheme, and a few ZK proofs for the \NP-relations the scheme induces. Actually, we use a ``twisted'' variant of this scheme, that enjoys more efficient Schnorr proofs.   The chunk ElGamal  scheme is defined in \cref{sec:ChanksEG:EGScheme}, and the related ZK proofs are defined in \cref{sec:ChanksEG:Proofs}. Finally, in \cref{sec:ChanksEG:Adjusting} we explain  how to adjust \cref{prot:ConfidentialTransactions} to work with this almost homomorphic scheme.

\subsection{Twisted ElGamal In-the-Exponent Encryption Scheme}\label{sec:ChanksEG:TEG}
Throughout we fix a cyclic  additive $q$-size group $\cG$ with generator $G$. The  twisted ElGamal in-the-exponent encryption scheme $(\tEgKG,\tEgEnc,\tEgDec)$ is defined below. Note that it  gets  $H\in \cG$ as an  additional parameter.

\begin{algorithm}[$(\tEgKG,\tEgEnc,\tEgDec)$: Twisted ElGamal in-the-exponent encryption]\label{alg:TEGinExp}~
	
	
	\item[Key generation:] $\tEgKG(1^b,H)$ samples $e\getsr \Z_q$, and outputs $(\sk 
	\asn e,\pk \asn (1^b,H,E\asn  e^{-1}\cdot H))$.
	
	\item[Encryption:] $\tEgEnc_{(H,E)}(a)$  samples $r\getsr \Z_q$, and outputs  $\tA \asn (r\cdot E, \Ped_H(a;r))$, for 
	$\Ped_H(a;r) \eqdef r\cdot H + a \cdot G$.
	
	
	\item[Decryption:] $\tEgDec_{(1^b,H,e)}(\tA)$,   
	\begin{enumerate}
		\item 	Let $M \asn \tA_1 - e\cdot \tA_0$.
		
		\item Find (using brute force) $m\in (-b, b) \in \Z_q$ so that $m\cdot G = M$. Abort if no such $m$ exists.
		
		\item Output $m$.
	\end{enumerate}
	
	\item[Addition:] Addition over  $\cG^2$.\footnote{For $\tA,\tB \in \cG^2$: $\tA +\tB \eqdef (\tA_0+\tB_0,\tA_1+\tB_1)$.}
	
	\item[Minus:]  The inverse in $\cG^2$.
	
\end{algorithm}	
When clear from the context,  will omit the parameters $1^b$ from the public key of the scheme.

\begin{theorem}[Security  of twisted-ElGamal in-the-exponent]\label{thm:tEGinExp}
	Assuming DDH is hard over $\cG$, then \cref{alg:EGinExp} is  a perfectly binding,  semantically secure additively homomorphic scheme over $\Z_q$, with the following caveat:  the description only guaranteed to work on encryptions of explain in $(b)$,   for $1^b$ being the input of the key generation algorithm:
\end{theorem}



\subsubsection{Zero-Knowledge Proofs}
In \cref{sec:ChanksEG:EGScheme} we make use of ZK proofs for the following relations regrading the above scheme.  


\begin{description}
	\item[Knowledge of secret key.] ~
	
	
	
	\begin{description}
		\item[Task:] ZKPOK for $\rtEgKeyGen = \rtEgKeyGenDef$.
		
		\item[Proof:] This is just standard Schnorr proof for discrete log \cite{Shoup00b}.
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for $\rtEGEnc=\rtEGEncDef$.
		
		\item[Proof:] Apply the Knowledge of plain text proof (see  \cite[Protocol A.1]{HaitnerLNR23}) for the relation
		
		$$\rPedEnc = \rPedEncDef $$
		Namely, the proof is only applied to  $\tA_1$, \ie the right hand side of the ciphertext. 
		
	\end{description}
	
	
	\item[Equality.] ~
	\begin{description}
		\item[Task:] ZKP for $\rtEgEq =\rtEgEqDef$.
		
		\item[Proof:] The sigma protocol for this relation concatenates, with the same challenge $e$ and answer $z$, two proofs of $\rtEGEnc$. 
	\end{description}
	
	
	\item[In range.] ~
	\begin{description}
		\item[Task:] ZKP for $\rtEgRp =\rtEgRpDef$.
		
		\item[Proof:] Use \textit{bullet proofs} \cite{SP:BBBPWM18} on $\tA_1$ (\ie right hand side of $\tA$). 
	\end{description}
	
	
	
\end{description}


	
\subsection{The Chunk-ElGamal  Scheme}\label{sec:ChanksEG:EGScheme}
In the following we fix $t,c\in \N$ with $t\le q$ and $\ell \asn t/c \in \N$. The chunk ElGamal encryption scheme  is defined as follows:



\begin{definition}[Base factorization]\label{def:basefactor}
For $a\in \Z_q$ let $a_0,\ldots,a_{\ell-1}$ so that $a =  \sum_{i \in (\ell)}    2^{i c} \cdot a_i$.
\end{definition}


\begin{algorithm}[$(\KeyGen,\Enc,\Dec)$: Chunk ElGamal adaptively homomorphic encryption]\label{alg:ChunkEGa}~
	
	\item[Key generation:] $\KeyGen(1^b,H)$: act as $\tEgKG(1^b,H)$.
	
	\item[Encryiption:] $\Enc_\pk(a)$
	
	\begin{enumerate}
		\item Compute $(a_0,\ldots,a_{\ell-1}) \asn \basefactor(a)$.
		
		\item For each $i\in (\ell)$: let $\tA_i \getsr \tEgEnc_\pk(a_i)$.
		
		\item Output $\oA \asn (\tA_0,\ldots, \tA_{\ell-1})$.
		
	\end{enumerate}
	 
	\item[Decription:] $\Dec_\sk(\oM,b)$   
	\begin{enumerate}
		\item 	 For each $i\in (\ell)$: let $m_i \getsr \tEgDec_\sk(\oM_i,b)$.
		
		\item Let  $m \asn \sum_{i \in (\ell)}   2^{i c} \cdot  m_i $.
		
		\item Output $m$.
	\end{enumerate}
	
	\item[Addition:] Vector addition.\footnote{For $\oA,\oB \in (\cG^2)^\ell$, $\oA +\oB \eqdef (\tA_0+\tB_0,\ldots,\tA_{\ell-1}+\tB_{\ell-1})$.}
	
	\item[Minus:]  Vector negation.
	                     
	
\end{algorithm}


\begin{theorem}[Security  of Chunk ElGamal]\label{thm:ChunkEG}
	Assuming \DDH is hard over $\cG$, then \cref{alg:ChunkEGa} is  a perfectly binding,  semantically secure additively homophobic scheme over $\Z_q$, with the following caveat work on encryptions of plaintext  $a$ so that $\basefactor(a)\in (-b,b)^\ell$ ($1^b$ being the input of the key generation algorithm).
\end{theorem}


\subsection{Zero-Knowledge  Proofs for the Scheme }\label{sec:ChanksEG:Proofs}
In this section, we define the ZK and POK proofs used in  \cref{sec:MainProtocol}.
In the following, we omit the parameter $b$ from the input list of  \Dec.  We will address its value in \cref{sec:ChanksEG:Adjusting}.


\begin{description}
	\item[Knowledge of secret key.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for $\rKeyGen=\rKeyGenDef$.
		
		\item[Proof:] Same as \piZKPOK{\rtEgKeyGen}. 
		
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	

	\begin{description}
		\item[Task:] ZKPOK for $\rEnc=\rEncDef$.
		
		\item[\Pc:] On  input  $((\pk,\oA),(\oa,\orr)$.
		\begin{enumerate}
			\item For each $i\in (\ell)$: let  $\pi_i \asn \piZKPOK{\rtEGEnc}((\pk,\oA_i),(\oa_i,\orr_i))$. 
			
			\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
			
		\end{enumerate}
		
		
	\item[\Vc:] On  input  $((\pk,\oA),\pi = (\pi_0,\ldots, \pi_{\ell-1}))$:
	
	 Accept iff  $\vZK{\rtEGEnc}((\pk,\tA_i), \pi_i)$ for all $i\in (\ell)$.
		
	\end{description}
	
\item[Equality.]~ 


\begin{description}
	\item[Task:] ZKP for $\rEq =\rEqDef$.
	
	\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(\oa,\orr_0,\orr_1))$: 
	

	\begin{enumerate}
		
		\item Let  $a \asn  \sum_{i\in (\ell)}    2^c \cdot \oa_i$. 
		
		\item For both $j\in \zo$:
		\begin{enumerate}
			\item    $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
			\item    $r_j \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_j)_i$. 
			
		\end{enumerate}
		
		\item Output $\pi \asn \pZK{\rtEgEq}((\pk,\tA_0,\tA_1), (a,r_0,r_1))$.
				 
	\end{enumerate}
	
	\item[\Vc:] On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi)$: 
	
	\begin{enumerate}
		\item Generate $\tA_0$ and  $\tA_1$ as done by \Pc.
		
	\item Apply $\vZK{\rtEgEq}((\pk,\tA_0,\tA_1), \pi)$.
	
	\end{enumerate}
	
	\end{description}
		


  


\item[In range.]~  

\begin{description}
	\item[Task:] ZK for $\rRp =\rRpDef$.
	
	\item[\Pc:] On input $((\pk,\oA,b),(\oa,\orr))$:
	
	\begin{enumerate}
			\item   $a \asn  \sum_{i\in (\ell)}   2^c \cdot \oa_i$. 
		\item    $\tA \asn  \sum_{i\in (\ell)}    2^c \cdot \oA_i$. 
		\item    $r \asn  \sum_{i\in (\ell)}  2^c \cdot \orr_i$. 
        
        \item  Output $\pi \asn \pZK{\rtEgRp}((\pk,\tA,b), (a,r))$.
        
	\end{enumerate}
	
	
\item[\Vc:] On input $((\pk,\oA,b),\pi)$:
	
	\begin{enumerate}
		\item   Generate $\tA$ as by \Pc.
		\item  Output $\vZK{\rtEgRp}((\pk,\tA,b), \pi)$.
		
	\end{enumerate}
	
	
\end{description}

		
\remove{		
\item[Larger than.]~  

\begin{description}
	\item[Task:] POK for $\rLrgEq =\rLrgEqDef$.
	
		\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(\oa,\orr_0,\orr_1))$: 
	
	
	\begin{enumerate}
		
		\item For both $j\in \zo$:
		
		\begin{enumerate}
			\item   $a_j \asn  \sum_{i\in (\ell)}    2^c \cdot (\oa_j)_i$. 
			
				\item    $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
				\item    $r_j \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_j)_i$. 
				   
		\end{enumerate}
		
		\item Let $\tA \asn \tA_1 - \tA_0$, $a \asn a_1 - a_0$ and $r \asn r_1 - r_0$.
		\item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,q), (a,r))$.
	\end{enumerate}
	
	
	\item[\Vc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi$: 
	
	\begin{enumerate}
		\item  Generate $\tA$ as by \Pc.
		
		\item  Output $\vZK{\rEgRp}((\pk,\tA,q), \pi)$.
		
	\end{enumerate}
\end{description}
}

\item[Freshness.]  ~
Proving that each of the entries of the  ciphertext are small. 

\begin{description}
	\item[Task:] ZKP for $\rtFsh =\rtFshDef$.
	
	\item[\Pc:] On  input  $((\pk,\oA,b),(\oa,\orr)$:
	
	\begin{enumerate}
		\item For each $i\in (\ell)$: $\pi_i \asn \pZK{\rtEgRp}((\pk,\tA_i,b), (\oa_i,\orr_i))$.
		\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
	\end{enumerate}
	 
	 
	 	\item[\Vc:] On  input  $((\pk,\oA,b), \pi= (\pi_0,\ldots, \pi_{\ell-1}))$:
	 
	 Accept iff  $\vZK{\rtEgRp}((\pk,\tA_i,b), \pi_i)$ for all $i\in (\ell)$.
	 
	 
\end{description}


\end{description}


\subsection{Adjusting  \cref{prot:ConfidentialTransactions}}\label{sec:ChanksEG:Adjusting}
Since the decryption procedure of of chunk-ElGamal  encryption scheme only guarantees to work on certain type of ciphertexts, see \cref{thm:ChunkEG} and take a group element, \ie $H$, as an additional parameter,  instantiating \cref{prot:ConfidentialTransactions} with this scheme  requires some adjustments.

\begin{enumerate}
	
	\item[Init:] 
	\begin{enumerate}
		\item The parties  call an ideal functionality that returns $H \getsr \cG$.\footnotetext{Can be implemented using a proper protocol, ot sampled by a trusted  setup.}
		  
		\item 	Each $\Uc_i$ sets the parameters of the encryption key generation algorithm to $(1^b,H)$, for  $b \asn 2^{c}\cdot \pcount$.

	\end{enumerate}
 
	\item[Transfer.]  The sender also provide proofs that $X_d$ is fresh (\ie using \pZK{\rtFsh} with parameter $b\asn 2^c$).
	
	
	\item[Rollover:] The rollover over operation should be updated to allow the account holder to ``normalize''  its active balance: to make it fresh. Specifically
	
	\begin{enumerate}
		\item $\Uc_i$:
		
		\begin{enumerate}
			\item Decrypt $\oP_i$ and $\oB_i$ to get value $(p_i,r_i)$ and $(b_i,w_i)$ respectively.
			
			
			\item Generate a fresh  encryption $\oB_i'$ of $(p_i +b_i )$ and $\oP_i'$ of $0$.
			
			\item Generate a proof $\pi_\Eqs$ (\ie using \pZK{\rEq})   that $\oP_i+\oB_i = \oP_i'+ \oB_i'$.
			
			
		%	\item  Generate proofs $\pi^P_\Fshs$ and $\pi^B_\Fshs$ (\ie using \pZK{\rtFsh})   that $\oP_i'$ and $\oB_i'$ are fresh.
			
			\item Send $(\oP_i',\oB_i',\pi_\Eqs,\pi^P_\Fshs,\pi^B_\Fshs)$ to \Cc.
		%
			\item Send $(\oP_i',\oB_i',\pi_\Eqs)$ to \Cc.
		
		
		\end{enumerate}
		
		\item $\Cc$:
			\begin{enumerate}
			%	\item Verify $\pi_\Eqs,\pi^P_\Fshs$ and $\pi^B_\Fshs$.
				
					\item Verify $\pi_\Eqs$.
				
				\item Set $\oP_i  \asn \oP_i'$  and $\oB_i  \asn \oB_i'$.
				
				\item Continue as in the original protocol.
			\end{enumerate}
		
	\end{enumerate}
\end{enumerate}


\subsection{Efficient Improvements}\label{sec:ChanksEG:EfficientImp}

\begin{enumerate}
	\item The bullet proofs used  in the In range and the freshness proofs can be batched. 
	
\end{enumerate}