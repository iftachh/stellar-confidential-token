
\newcommand{\EgKG}{\MathAlgX{EgGen}}
\newcommand{\EgEnc}{\MathAlgX{EgEnc}}
\newcommand{\EgDec}{\MathAlgX{EgDec}}


\newcommand{\rEgKeyGen}{{\cR_{\sf EGKeyGen}}}

\newcommand{\rEgKeyGenDef}
{
	\set{(E,e))\colon e\cdot G= E}
}


\newcommand{\rEGEnc}{{\cR_{\sf EgEnc}}}

\newcommand{\rEGEncDef}
{
	\set{((E,\tA),(a,r))\colon \EgEnc_E(a;r)= \tA}
}


\newcommand{\rDec}{{\cR_{\sf Dec}}}
\newcommand{\rDecDef}
{
	\set{((\pk,\oA,b),(\oa,\orr))\colon \forall i\in (\ell)\colon  \EgEnc_\pk(\oa_i;\orr_i)= \oA_i  
		\sland \oa_i \in (b)}
}


\newcommand{\EgEqs}{{\sf EgEq}}
\newcommand{\rEgEq}{\cR_\Eqs}

\newcommand{\rEgEqDef}
{
	\set{((E_0,E_1,\tA_0,\tA_1),(a,r_0,r_1))\colon \forall i\in \zo \; \EgEnc_{E_i}(a;r_i)= \tA_i}
}


\newcommand{\EgRPs}{{\sf EgRp}}
\newcommand{\rEgRp}{\cR_\EgRPs}

\newcommand{\rEgRpDef}
{
	\set{((E,\tA,b),(a,r))\colon \Enc_E(a;r)= \tA \sland a\in (b)}
}


\newcommand{\EgLrgs}{{\sf EgLrger}}
\newcommand{\rEgLrg}{\cR_\EgLrgs}

\newcommand{\rEgLrgDef}
{
	\set{((E,\tA_0,\ttA_1),(a_0,r_0,a_1,r_1))\colon \forall i\in \zo \; \EgEnc_\pk(a_i;r_i)= A_i \sland a_1 -a_0 \in [q]} 
}





\section{The Chunk ElGamal  Encryption Scheme}\label{sec:ChanksEG}
In this section we define the (efficient)  close to being additive homomorphic encryption scheme based on ElGamal multiplicative  homomorphic encryption scheme.  \Inote{give citations}
The idea is to bootstrap the so-called   \textit{ElGamal in-the exponent}   additive homomorphic encryption  scheme,\footnote{It is called ElGamal ``in-the-exponent'' due to typical multiplicative group notation. Here use additive group notation, but keep the name for historical reason.}  which in turn is based on the  ElGamal multiplicative  homomorphic encryption scheme, that lacks efficient decryption algorithm, by splitting the plain text into small ``chunks''. That  is, we present message $m\in Z_t$ as $\sum_{i \in (t/c)}   2^{i c} \cdot a_i$, where $c$, the chunk size, is  some integer that divides $[t]$, and encrypt using    additive homomorphic EG each of the $a_i$. To decry $\oA= (A_0,\ldots,A_{t/c})$, one  
\begin{enumerate}
	\item Decrypt   each $A_i$ to get $a_i  \cdot G$.
	\item Use brute force to find $a$.\footnote{One can use standard   processing to speed-up this part from $c$ group operations to $\sqrt{c}$  operations, or even \Inote{cite} to   $\sqrt[3]{c}$.}
	
	\item Reconstruct $a$.
\end{enumerate}
In \cref{sec:ChanksEG:EG} we formally define the ElGamal in-the-exponent scheme, and a few ZK proofs for the \NP-relations the scheme induces. The chunk ElGamal  scheme is defined in \cref{sec:ChanksEG:EGScheme} and the related ZK proofs, are defined in \cref{sec:ChanksEG:Proofs}. Finally, in \cref{sec:ChanksEG:Adjusting} we explain  how to adjust \cref{prot:ConfidentialTransactions} tp work with the new scheme.


\subsection{ElGamal In-the-Exponent Scheme}\label{sec:ChanksEG:EG}

Throughout we fix a cyclic  additive $q$-size group $\cG$ with generator $G$. The  ElGamal in-the-exponent encryption scheme $(\EgKG,\EgEnc,\EgDec)$ is define as follows:

\begin{algorithm}[$(\EgKG,\EgEnc,\EgDec)$: ElGamal in-the-exponent encryption]\label{alg:EGinExp}~
\item[Key generation:] $\EgKG()$ samples $e\getsr \Z_q$, and outputs $(e,e\cdot G)$.
	
	\item[Encryption:] $\EgEnc_E(a)$  samples $e\getsr \Z_q$, and outputs  $\tA \asn (r\cdot G, r\cdot E + a \cdot G)$
	
	
		\item[Decryption:] $\EgDec_e(\tA,b)$,   
		\begin{enumerate}
			\item 	Let $M \asn \tA_2 - e\cdot \tA_2$.
			
			\item Find (using brute force) $m\le b$ so that $m\cdot G = M$. Abort if no such $m$ exists.
			
			\item Output $m$.
		\end{enumerate}
\end{algorithm}	

Note that 	the decryption algorithm gets an additional parameter, \ie $b$, to limit its running time.  
	
\subsubsection{Zero-Knowledge Proofs}
In \cref{sec:ChanksEG:EGScheme} we make use of ZK proofs for the following relations regrading the above scheme. 
	
	
\begin{description}
	\item[Knowledge of secret key.] ~
    


\begin{description}
	\item[Task:] ZKPOK for $\rEgKeyGen = \rEgKeyGenDef$.
	
\item[Proof:] \Inote{Schnorr proof. Give ref}
\end{description}


\item[Knowledge of plain text.] ~

\begin{description}
	\item[Task:] ZKPOK for $\rEGEnc=\rEGEncDef$.
	
	\item[Proof:] \Inote{Schnorr proof. Give ref}
	
\end{description}


\item[Equality.] ~
\begin{description}
	\item[Task:] ZKP for $\rEgEq =\rEgEqDef$.
	
	\item[Proof:] \Inote{Schnorr proof. Give ref}
\end{description}


\item[In range.] ~
\begin{description}
	\item[Task:] ZKP for $\rEgRp =\rEgRpDef$.
	
	\item[Proof:] \Inote{Bullet proof. Give ref}
\end{description}



\end{description}

	
\subsection{The Chunk ElGamal  Scheme}\label{sec:ChanksEG:EGScheme}
In the following we fix $t,c\in \N$ with $t\le q$ and $\ell \asn t/c \in \N$. The chunk ElGamal encryption scheme  is defined as follows:

\begin{algorithm}[$(\KeyGen,\Enc,\Dec)$: Chunk ElGamal adaptively homomorphic encryption] \label{alg:ChunkEG}~
	
	\item[Key generation:] $\KeyGen()$: act as $\EgKG()$.
	
	\item[Encryiption:] $\Enc_\pk(a)$
	
	\begin{enumerate}
		\item Compute $a_0,\ldots,a_{\ell-1}$ so that $a =  \sum_{i \in (\ell)}    2^{i c} \cdot a_i$.
		\item For each $i\in (\ell)$: let $\tA_i \getsr \EgEnc_\pk(a_i)$.
		
		\item Output $\oA \asn (\tA_0,\ldots, \tA_{\ell-1})$.
		
	\end{enumerate}
	 
	\item[Decription:] $\Dec_\sk(\oM,b)$   
	\begin{enumerate}
		\item 	 For each $i\in (\ell)$: let $m_i \getsr \EgDec_\sk(\oM_i,b)$.
		
		\item Let  $m \asn \sum_{i \in (\ell)}   2^{i c} \cdot  m_i $.
		
		\item Output $m$.
	\end{enumerate}
\end{algorithm}


\begin{theorem}[Security of \cref{alg:ChunkEG}]\label{thm:ChunkEG}~
\Inote{TODO. In particular states  its (limited)  additive homomorphic properties}
\end{theorem}

\begin{remark}[Limitations of \cref{alg:ChunkEG}]\label{rem:ChunkEG}
We explicitly mention what prevent \label{alg:ChunkEG}  from being considered as a truly additive homomorphic scheme.
\begin{enumerate}
	\item Adding ciphertexts might generate ciphertexts that cannot be decrypt.
	
	\item Adding ciphertexts that cause overflow in one of the chunk will might generate  a ciphertexts of a wrong value. In particular, this might be the case when  \emph{subtracting}  ciphertext from the other. The action $\oA - \oB$ translates to $\oA + \oB'$ where $\oB'_i = \Enc(q-b_i)$ for $b_i$ being the value encrypted by  $ \oB_i$. Thus overflow might occur even if  all entries of $\oA $ and $\oB$ encrypt small values. 

\end{enumerate}

\end{remark}


\subsection{Zero-Knowledge  Proofs for the Scheme }\label{sec:ChanksEG:Proofs}
In this section, we define the ZK and POK proofs used in  \cref{sec:MainProtocol}.
In the following, we omit the parameter $b$ from the input list of  \Dec.  We will address its value in \cref{sec:ChanksEG:Adjusting}.


\begin{description}
	\item[Knowledge of secret key.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for $\rKeyGen=\rKeyGenDef$.
		
		\item[Proof:] Same as \piZKPOK{\rEgKeyGen}. 
		
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	

	\begin{description}
		\item[Task:] ZKPOK for $\rEnc=\rEncDef$.
		
		\item[\Pc:] On  input  $((\pk,\oA),(\oa,\orr)$.
		\begin{enumerate}
			\item For each $i\in (\ell)$: let  $\pi_i \asn \piZKPOK{\rEGEnc}((\pk,\oA_i),(\oa_i,\orr_i))$. 
			
			\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
			
		\end{enumerate}
		
		
	\item[\Vc:] On  input  $((\pk,\oA),\pi = (\pi_0,\ldots, \pi_{\ell-1}))$:
	
	 Accept iff  $\vZK{\rEGEnc}((\pk,\tA_i), \pi_i)$ for all $i\in (\ell)$.
		
	\end{description}
	
\item[Equality.]~ 


\begin{description}
	\item[Task:] ZKP for $\rEq =\rEqDef$.
	
	\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(\oa,\orr_0,\orr_1))$: 
	

	\begin{enumerate}
		
		\item Let  $a \asn  \sum_{i\in (\ell)}    2^c \cdot \oa_i$. 
		
		\item For both $j\in \zo$:
		\begin{enumerate}
			\item    $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
			\item    $r_j \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_j)_i$. 
			
		\end{enumerate}
		
		\item Output $\pi \asn \pZK{\rEgEq}((\pk,\tA_0,\tA_1), (a,r_0,r_1))$.
				 
	\end{enumerate}
	
	\item[\Vc:] On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi)$: 
	
	\begin{enumerate}
		\item Generate $\tA_0$ and  $\tA_1$ as done by \Pc.
		
	\item Apply $\vZK{\rEgEq}((\pk,\tA_0,\tA_1), \pi)$.
	
	\end{enumerate}
	
	\end{description}
		


  


\item[In range.]~  

\begin{description}
	\item[Task:] ZK for $\rRp =\rRpDef$.
	
	\item[\Pc:] On input $((\pk,\oA,b),(\oa,\orr))$:
	
	\begin{enumerate}
			\item   $a \asn  \sum_{i\in (\ell)}   2^c \cdot \oa_i$. 
		\item    $\tA \asn  \sum_{i\in (\ell)}    2^c \cdot \oA_i$. 
		\item    $r \asn  \sum_{i\in (\ell)}  2^c \cdot \orr_i$. 
        
        \item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,b), (a,r))$.
        
	\end{enumerate}
	
	
\item[\Vc:] On input $((\pk,\oA,b),\pi)$:
	
	\begin{enumerate}
		\item   Generate $\tA$ as by \Pc.
		\item  Output $\vZK{\rEgRp}((\pk,\tA,b), \pi)$.
		
	\end{enumerate}
	
	
\end{description}

		
\item[Larger than.]~  

\begin{description}
	\item[Task:] POK for $\rLrgEq =\rLrgEqDef$.
	
		\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(\oa,\orr_0,\orr_1))$: 
	
	
	\begin{enumerate}
		
		\item For both $j\in \zo$:
		
		\begin{enumerate}
			\item   $a_j \asn  \sum_{i\in (\ell)}    2^c \cdot (\oa_j)_i$. 
			
				\item    $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
				\item    $r_j \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_j)_i$. 
				   
		\end{enumerate}
		
		\item Let $\tA \asn \tA_1 - \tA_0$, $a \asn a_1 - a_0$ and $r \asn r_1 - r_0$.
		\item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,q), (a,r))$.
	\end{enumerate}
	
	
	\item[\Vc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi$: 
	
	\begin{enumerate}
		\item  Generate $\tA$ as by \Pc.
		
		\item  Output $\vZK{\rEgRp}((\pk,\tA,q), \pi)$.
		
	\end{enumerate}
\end{description}
 


\item[Decryptability.]  ~


\begin{description}
	\item[Task:] ZKP for $\rDec =\rDecDef$.
	
	\item[\Pc:] On  input  $((\pk,\oA,b),(\oa,\orr)$:
	
	\begin{enumerate}
		\item For each $i\in (\ell)$: $\pi_i \asn \pZK{\rEgRp}((\pk,\tA_i,b), (\oa_i,\orr_i))$.
		\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
	\end{enumerate}
	 
	 
	 	\item[\Vc:] On  input  $((\pk,\oA,b), \pi= (\pi_0,\ldots, \pi_{\ell-1}))$:
	 
	 Accept iff  $\vZK{\rEgRp}((\pk,\tA_i,b), \pi_i)$ for all $i\in (\ell)$.
	 
	 
\end{description}


\end{description}


\subsection{Adjusting  \cref{prot:ConfidentialTransactions}}\label{sec:ChanksEG:Adjusting}
Since the chunk ElGamal  scheme has some shortcoming to be considered as truly additive  homomorphic shame, see \cref{rem:ChunkEG}, instantiating \cref{prot:ConfidentialTransactions} with the new scheme  requires some adjustments.

\Inote{Set bound parameter  for decryption algorithm}

\begin{enumerate}
	\item[Transfer.]  The sender also provide proofs that
	
	\begin{enumerate}
		\item $X_d$ is decryptable (\ie using \pZK{\rDec} with parameter $b\asn 2^c$).
		
		\item $B_s$ is \emph{point-wise} larger  equal than $X_s$, \Inote{do we need it?}
	\end{enumerate} 
	
	\item[Rollover:] The rollover over operation should be updated to allow the account holder to ``normalize''  it active balance: to make it decryptable. Specifically
	
	\begin{enumerate}
		\item $\Uc_i$:
		
		\begin{enumerate}
			\item Decrypt $\oP_i$ and $\oB_i$ to get value $(p_i,r_i)$ and $(b_i,w_i)$ respectively.
			
			
			\item Generate a fresh  encryption $\oB_i'$ of $(p_i +b_i )$ and $\oP_i'$ of $0$.
			
			\item Generate a proof $\pi$ (\ie using \pZK{\rEq})   that $\oP_i+\oB_i = \oP_i'+ \oB_i'$.
			
			\item Send $(\oP_i',\oB_i',\pi)$ to \Cc.
		
		\end{enumerate}
		
		\item $\Cc$:
			\begin{enumerate}
				\item Verify $\pi$.
				
				\item Set $\oP_i  \asn \oP_i'$  and $\oB_i  \asn \oB_i'$.
				
				\item Continue as in the original protocol.
			\end{enumerate}
		
	\end{enumerate}
\end{enumerate}