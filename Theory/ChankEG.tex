
\newcommand{\EgKG}{\MathAlgX{EgGen}}
\newcommand{\EgEnc}{\MathAlgX{EgEnc}}
\newcommand{\EgDec}{\MathAlgX{EgDec}}


\newcommand{\rEgKeyGen}{{\cR_{\sf EGKeyGen}}}

\newcommand{\rEgKeyGenDef}
{
	\set{(E,e))\colon e\cdot G= E}
}


\newcommand{\rEGEnc}{{\cR_{\sf EgEnc}}}

\newcommand{\rEGEncDef}
{
	\set{((E,\tA),(a,r))\colon \EgEnc_E(a;r)= \tA}
}

\newcommand{\Fshs}{{\sf Fsh}}
\newcommand{\rFsh}{{\cR_\Fshs}}
\newcommand{\rFshDef}
{
	\set{((\pk,\oA,b),(\oa,\orr))\colon \forall i\in (\ell)\colon  \EgEnc_\pk(\oa_i;\orr_i)= \oA_i  
		\sland \oa_i \in (b)}
}


\newcommand{\EgEqs}{{\sf EgEq}}
\newcommand{\rEgEq}{\cR_\Eqs}

\newcommand{\rEgEqDef}
{
	\set{((E_0,E_1,\tA_0,\tA_1),(a,r_0,r_1))\colon \forall i\in \zo \; \EgEnc_{E_i}(a;r_i)= \tA_i}
}


\newcommand{\EgRPs}{{\sf EgRp}}
\newcommand{\rEgRp}{\cR_\EgRPs}

\newcommand{\rEgRpDef}
{
	\set{((E,\tA,b),(a,r))\colon \Enc_E(a;r)= \tA \sland a\in (b)}
}


\newcommand{\EgLrgs}{{\sf EgLrger}}
\newcommand{\rEgLrg}{\cR_\EgLrgs}

\newcommand{\rEgLrgDef}
{
	\set{((E,\tA_0,\ttA_1),(a_0,r_0,a_1,r_1))\colon \forall i\in \zo \; \EgEnc_\pk(a_i;r_i)= A_i \sland a_1 -a_0 \in [q]} 
}





\section{The Chunk-ElGamal  Encryption Scheme}\label{sec:ChanksEG}
In this section we define the (efficient)  close to being additive homomorphic encryption scheme based on ElGamal multiplicative  homomorphic encryption scheme.  \Inote{give citations}
The idea is to bootstrap the so-called   \textit{ElGamal in-the exponent}   additive homomorphic encryption  scheme,\footnote{It is called ElGamal ``in-the-exponent'' due to typical multiplicative group notation. Here use additive group notation, but keep the name for historical reason.}  which in turn is based on the  ElGamal multiplicative  homomorphic encryption scheme, that lacks efficient decryption algorithm, by splitting the plain text into small ``chunks''. That  is, we present message $m\in Z_t$ as $\sum_{i \in (t/c)}   2^{i c} \cdot a_i$, where $c$, the chunk size, is  some integer that divides $[t]$, and encrypt using    additive homomorphic EG each of the $a_i$. To decry $\oA= (A_0,\ldots,A_{t/c})$, one  
\begin{enumerate}
	\item Decrypt   each $A_i$ to get $a_i  \cdot G$.
	\item Use brute force to find $a$.\footnote{One can use standard   processing to speed-up this part from $c$ group operations to $\sqrt{c}$  operations, or even \Inote{cite} to   $\sqrt[3]{c}$.}
	
	\item Reconstruct $a$.
\end{enumerate}
In \cref{sec:ChanksEG:EG} we formally define the ElGamal in-the-exponent scheme, and a few ZK proofs for the \NP-relations the scheme induces. The chunk ElGamal  scheme is defined in \cref{sec:ChanksEG:EGScheme} and the related ZK proofs, are defined in \cref{sec:ChanksEG:Proofs}. Finally, in \cref{sec:ChanksEG:Adjusting} we explain  how to adjust \cref{prot:ConfidentialTransactions} tp work with the new scheme.


\subsection{ElGamal In-the-Exponent Encryption Scheme}\label{sec:ChanksEG:EG}

Throughout we fix a cyclic  additive $q$-size group $\cG$ with generator $G$. The  ElGamal in-the-exponent encryption scheme $(\EgKG,\EgEnc,\EgDec)$ is define as follows:

\begin{algorithm}[$(\EgKG,\EgEnc,\EgDec)$: ElGamal in-the-exponent encryption]\label{alg:EGinExp}~
	
	
\item[Key generation:] $\EgKG(1^b)$ samples $e\getsr \Z_q$, and outputs $((1^b,e),E\asn  e\cdot G)$.
	
	\item[Encryption:] $\EgEnc_E(a)$  samples $e\getsr \Z_q$, and outputs  $\tA \asn (r\cdot G, r\cdot E + a \cdot G)$
	
	
		\item[Decryption:] $\EgDec_{1^b,e}(\tA)$,   
		\begin{enumerate}
			\item 	Let $M \asn \tA_2 - e\cdot \tA_2$.
			
			\item Find (using brute force) $m\in (-b, b) \in \Z_q$ so that $m\cdot G = M$. Abort if no such $m$ exists.
			
			\item Output $m$.
		\end{enumerate}
		
		\item[Addition:] Addition over  $\cG^2$.\footnote{For $\tA,\tB \in \cG^2$: $\tA +\tB \eqdef (\tA_0+\tB_0,\tA_1+\tB_1)$.}
		
		\item[Minus:]  The inverse in $\cG^2$.
		
\end{algorithm}	
When clear from the context,  will omit the parameter $1^b$ from the secret key of the scheme.

\begin{theorem}[Security  of ElGamal in-the-exponent]\label{thm:EGinExp}
	Assuming DDH is hard over $\cG$, then \cref{alg:EGinExp} is  a perfectly binding,  semantically secure additively homomorphic scheme over $\Z_q$, with the following caveat:  the description only guaranteed to work on encryptions of explain in $(b)$,   for $1^b$ being the input of the key generation algorithm:
\end{theorem}



\subsubsection{Zero-Knowledge Proofs}
In \cref{sec:ChanksEG:EGScheme} we make use of ZK proofs for the following relations regrading the above scheme. 
	
	
\begin{description}
	\item[Knowledge of secret key.] ~
    


\begin{description}
	\item[Task:] ZKPOK for $\rEgKeyGen = \rEgKeyGenDef$.
	
\item[Proof:] This is just standard Schnorr proof for discrete log \cite{Shoup00b}.
\end{description}


\item[Knowledge of plain text.] ~

\begin{description}
	\item[Task:] ZKPOK for $\rEGEnc=\rEGEncDef$.
	
	\item[Proof:] See  \cite[Protocol A.2]{HaitnerLNR23}.
	
\end{description}


\item[Equality.] ~
\begin{description}
	\item[Task:] ZKP for $\rEgEq =\rEgEqDef$.
	
	\item[Proof:] The sigma protocol for this relation concatenates, with the same challenge $e$ and answer $z$, two proofs of $\rEGEnc$. 
\end{description}


\item[In range.] ~
\begin{description}
	\item[Task:] ZKP for $\rEgRp =\rEgRpDef$.
	
	\item[Proof:] \Inote{Bullet proof. Give ref}
\end{description}



\end{description}

	
\subsection{The Chunk-ElGamal  Scheme}\label{sec:ChanksEG:EGScheme}
In the following we fix $t,c\in \N$ with $t\le q$ and $\ell \asn t/c \in \N$. The chunk ElGamal encryption scheme  is defined as follows:


\newcommand{\basefactor}{\MathAlgX{baseF}}
\begin{definition}[Base factorization]\label{def:basefactor}
For $a\in \Z_q$ let $a_0,\ldots,a_{\ell-1}$ so that $a =  \sum_{i \in (\ell)}    2^{i c} \cdot a_i$.
\end{definition}

\begin{algorithm}[$(\KeyGen,\Enc,\Dec)$: Chunk ElGamal adaptively homomorphic encryption]\label{alg:ChunkEGa}~
	
	\item[Key generation:] $\KeyGen(1^b)$: act as $\EgKG(1^b)$.
	
	\item[Encryiption:] $\Enc_\pk(a)$
	
	\begin{enumerate}
		\item Compute $(a_0,\ldots,a_{\ell-1}) \asn \basefactor(a)$.
		
		\item For each $i\in (\ell)$: let $\tA_i \getsr \EgEnc_\pk(a_i)$.
		
		\item Output $\oA \asn (\tA_0,\ldots, \tA_{\ell-1})$.
		
	\end{enumerate}
	 
	\item[Decription:] $\Dec_\sk(\oM,b)$   
	\begin{enumerate}
		\item 	 For each $i\in (\ell)$: let $m_i \getsr \EgDec_\sk(\oM_i,b)$.
		
		\item Let  $m \asn \sum_{i \in (\ell)}   2^{i c} \cdot  m_i $.
		
		\item Output $m$.
	\end{enumerate}
	
	\item[Addition:] Vector addition.\footnote{For $\oA,\oB \in (\cG^2)^\ell$, $\oA +\oB \eqdef (\tA_0+\tB_0,\ldots,\tA_{\ell-1}+\tB_{\ell-1})$.}
	
	\item[Minus:]  Vector negation.
	                     
	
\end{algorithm}


\begin{theorem}[Security  of Chunk ElGamal]\label{thm:ChunkEG}
	Assuming \DDH is hard over $\cG$, then \cref{alg:ChunkEGa} is  a perfectly binding,  semantically secure additively homophobic scheme over $\Z_q$, with the following caveat work on encryptions of plaintext  $a$ so that $\basefactor(a)\in (-b,b)^\ell$ ($1^b$ being the input of the key generation algorithm).
\end{theorem}


\subsection{Zero-Knowledge  Proofs for the Scheme }\label{sec:ChanksEG:Proofs}
In this section, we define the ZK and POK proofs used in  \cref{sec:MainProtocol}.
In the following, we omit the parameter $b$ from the input list of  \Dec.  We will address its value in \cref{sec:ChanksEG:Adjusting}.


\begin{description}
	\item[Knowledge of secret key.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for $\rKeyGen=\rKeyGenDef$.
		
		\item[Proof:] Same as \piZKPOK{\rEgKeyGen}. 
		
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	

	\begin{description}
		\item[Task:] ZKPOK for $\rEnc=\rEncDef$.
		
		\item[\Pc:] On  input  $((\pk,\oA),(\oa,\orr)$.
		\begin{enumerate}
			\item For each $i\in (\ell)$: let  $\pi_i \asn \piZKPOK{\rEGEnc}((\pk,\oA_i),(\oa_i,\orr_i))$. 
			
			\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
			
		\end{enumerate}
		
		
	\item[\Vc:] On  input  $((\pk,\oA),\pi = (\pi_0,\ldots, \pi_{\ell-1}))$:
	
	 Accept iff  $\vZK{\rEGEnc}((\pk,\tA_i), \pi_i)$ for all $i\in (\ell)$.
		
	\end{description}
	
\item[Equality.]~ 


\begin{description}
	\item[Task:] ZKP for $\rEq =\rEqDef$.
	
	\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(\oa,\orr_0,\orr_1))$: 
	

	\begin{enumerate}
		
		\item Let  $a \asn  \sum_{i\in (\ell)}    2^c \cdot \oa_i$. 
		
		\item For both $j\in \zo$:
		\begin{enumerate}
			\item    $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
			\item    $r_j \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_j)_i$. 
			
		\end{enumerate}
		
		\item Output $\pi \asn \pZK{\rEgEq}((\pk,\tA_0,\tA_1), (a,r_0,r_1))$.
				 
	\end{enumerate}
	
	\item[\Vc:] On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi)$: 
	
	\begin{enumerate}
		\item Generate $\tA_0$ and  $\tA_1$ as done by \Pc.
		
	\item Apply $\vZK{\rEgEq}((\pk,\tA_0,\tA_1), \pi)$.
	
	\end{enumerate}
	
	\end{description}
		


  


\item[In range.]~  

\begin{description}
	\item[Task:] ZK for $\rRp =\rRpDef$.
	
	\item[\Pc:] On input $((\pk,\oA,b),(\oa,\orr))$:
	
	\begin{enumerate}
			\item   $a \asn  \sum_{i\in (\ell)}   2^c \cdot \oa_i$. 
		\item    $\tA \asn  \sum_{i\in (\ell)}    2^c \cdot \oA_i$. 
		\item    $r \asn  \sum_{i\in (\ell)}  2^c \cdot \orr_i$. 
        
        \item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,b), (a,r))$.
        
	\end{enumerate}
	
	
\item[\Vc:] On input $((\pk,\oA,b),\pi)$:
	
	\begin{enumerate}
		\item   Generate $\tA$ as by \Pc.
		\item  Output $\vZK{\rEgRp}((\pk,\tA,b), \pi)$.
		
	\end{enumerate}
	
	
\end{description}

		
\item[Larger than.]~  

\begin{description}
	\item[Task:] POK for $\rLrgEq =\rLrgEqDef$.
	
		\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(\oa,\orr_0,\orr_1))$: 
	
	
	\begin{enumerate}
		
		\item For both $j\in \zo$:
		
		\begin{enumerate}
			\item   $a_j \asn  \sum_{i\in (\ell)}    2^c \cdot (\oa_j)_i$. 
			
				\item    $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
				\item    $r_j \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_j)_i$. 
				   
		\end{enumerate}
		
		\item Let $\tA \asn \tA_1 - \tA_0$, $a \asn a_1 - a_0$ and $r \asn r_1 - r_0$.
		\item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,q), (a,r))$.
	\end{enumerate}
	
	
	\item[\Vc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi$: 
	
	\begin{enumerate}
		\item  Generate $\tA$ as by \Pc.
		
		\item  Output $\vZK{\rEgRp}((\pk,\tA,q), \pi)$.
		
	\end{enumerate}
\end{description}
 


\item[Freshness.]  ~
Proving that each of the entries of the  ciphertext are small. 

\begin{description}
	\item[Task:] ZKP for $\rFsh =\rFshDef$.
	
	\item[\Pc:] On  input  $((\pk,\oA,b),(\oa,\orr)$:
	
	\begin{enumerate}
		\item For each $i\in (\ell)$: $\pi_i \asn \pZK{\rEgRp}((\pk,\tA_i,b), (\oa_i,\orr_i))$.
		\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
	\end{enumerate}
	 
	 
	 	\item[\Vc:] On  input  $((\pk,\oA,b), \pi= (\pi_0,\ldots, \pi_{\ell-1}))$:
	 
	 Accept iff  $\vZK{\rEgRp}((\pk,\tA_i,b), \pi_i)$ for all $i\in (\ell)$.
	 
	 
\end{description}


\end{description}


\subsection{Adjusting  \cref{prot:ConfidentialTransactions}}\label{sec:ChanksEG:Adjusting}
Since the decryption procedure of of chunk-ElGamal  encryption scheme only guarantees to work on certain type of ciphertexts, see \cref{thm:ChunkEG}, instantiating \cref{prot:ConfidentialTransactions} with this scheme  requires some adjustments.

\begin{enumerate}
	
	\item[Init:] Set the parameter of the encryption key generation algorithm to  $b \asn 2^{c}\cdot \pcount$.
	 
	\item[Transfer.]  The sender also provide proofs that $X_d$ is fresh (\ie using \pZK{\rFsh} with parameter $b\asn 2^c$).
	
	
	\item[Rollover:] The rollover over operation should be updated to allow the account holder to ``normalize''  its active balance: to make it fresh. Specifically
	
	\begin{enumerate}
		\item $\Uc_i$:
		
		\begin{enumerate}
			\item Decrypt $\oP_i$ and $\oB_i$ to get value $(p_i,r_i)$ and $(b_i,w_i)$ respectively.
			
			
			\item Generate a fresh  encryption $\oB_i'$ of $(p_i +b_i )$ and $\oP_i'$ of $0$.
			
			\item Generate a proof $\pi_\Eqs$ (\ie using \pZK{\rEq})   that $\oP_i+\oB_i = \oP_i'+ \oB_i'$.
			
			
			\item  Generate proofs $\pi^P_\Fshs$ and $\pi^B\Fshs$ (\ie using \pZK{\rFsh})   that $\oP_i'$ and $\oB_i'$ are fresh.
			
			\item Send $(\oP_i',\oB_i',\pi_\Eqs,\pi^P_\Fshs,\pi^B_\Fshs)$ to \Cc.
		
		\end{enumerate}
		
		\item $\Cc$:
			\begin{enumerate}
				\item Verify $\pi_\Eqs,\pi^P_\Fshs$ and $\pi^B_\Fshs$.
				
				\item Set $\oP_i  \asn \oP_i'$  and $\oB_i  \asn \oB_i'$.
				
				\item Continue as in the original protocol.
			\end{enumerate}
		
	\end{enumerate}
\end{enumerate}