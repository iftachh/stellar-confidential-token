
\newcommand{\basefactor}{\MathAlgX{baseFcts}}
\newcommand{\FshS}{{\sf Fsh}}

%%%%%%Twisted EG in the exponent
\newcommand{\EgKG}{\MathAlgX{EgGen}}

\newcommand{\EgEnc}{\MathAlgX{EgEnc}}
\newcommand{\EgDec}{\MathAlgX{EgDec}}



\newcommand{\EgKeyGens}{{{\sf EgKG}}}
\newcommand{\rEgKeyGen}{\cR_\EgKeyGens}
\newcommand{\rEgKeyGenDef}
{
	\sset{(E,e))\colon e\cdot G= E}
}


\newcommand{\EgEncs}{{{\sf EgEnc}}}
\newcommand{\rEgEnc}{\cR_\EgEncs}
\newcommand{\rEgEncDef}
{
	\sset{((H,E,\tA),(a,r))\colon \EgEnc_{(H,E)}(a;r)= \tA}
}


\newcommand{\rtFshs}{{{\sf EgFsh}}}
\newcommand{\rtFsh}{\cR_\rtFshs}
\newcommand{\rtFshDef}
{
	\sset{((\pk,\oA,b),(\oa,\orr))\colon \forall i\in (\ell)\colon  \EgEnc_\pk(\oa_i;\orr_i)= \oA_i  
		\sland \oa_i \in (b)}
}


\newcommand{\rEgEqs}{{{\sf EgEq}}}
\newcommand{\rEgEq}{\cR_\rEgEqs}

\newcommand{\rEgEqDef}
{
	\sset{(((H,E_0,E_1,\tA_0,\tA_1),(a,r_0,r_1))\colon \forall i\in \zo \colon \; \EgEnc_{(H,E_i)}(a;r_i)= \tA_i}
}


%\newcommand{\wEgEnc}{\MathAlgX{\widehat{EgEnc}}}
\newcommand{\wEgDec}{\MathAlgX{\widehat{EgDec}}}

\newcommand{\rEgEqWrS}{{{\sf EgEqWr}}}
\newcommand{\rEgEqWr}{\cR_\rEgEqWrS}

\newcommand{\rEgEqWrDef}
{
	\sset{((H,E,\tA_0,\tA_1),e)\colon   e\cdot   G = E \sland \wEgDec_e(\oA_0)= \wEgDec_e(\oA_1)}
}





\newcommand{\EgRps}{{{\sf EgRp}}}
\newcommand{\rEgRp}{\cR_\EgRps}
\newcommand{\rEgRpDef}
{
	\sset{((H,E,\tA,b),(a,r))\colon \EgEnc_{(H,E)}(a;r)= \tA \sland a\in (b)}
}



%%%%Pedersen
\newcommand{\Ped}{\MathAlgX{Ped}}



\newcommand{\PedEncs}{{\sf PedEnc}}
\newcommand{\rPedEnc}{\cR_\PedEncs}

\newcommand{\rPedEncDef}
{
	\sset{((H,A),(a,r))\colon \Ped_H(a;r)= A}
}





\section{The Chunk-ElGamal  Encryption Scheme}\label{sec:ChanksEg}
In this section, we define the  (almost) additive homomorphic encryption scheme based on ElGamal multiplicative  homomorphic encryption scheme.  \Inote{give citations}
The idea is to bootstrap the so-called   \textit{ElGamal in-the exponent}   additive homomorphic encryption/commitment  scheme,\footnote{It is called ElGamal ``in-the-exponent'' due to typical multiplicative group notation. Here use additive group notation, but keep the name for historical reason.}  which in turn is based on the  ElGamal multiplicative  homomorphic encryption scheme, that lacks efficient decryption algorithm, by splitting the plain text into small ``chunks''. That  is, we present a message $a\in Z_t$ as $\sum_{i \in (t/c)}   2^{i c} \cdot a_i$, where $c$, the chunk size, is  some inEgEr  dividing $t$, and encrypt each of the $a_i$ using    additive homomorphic EG. To decry $\oA= (A_0,\ldots,A_{t/c})$, one  
\begin{enumerate}
	\item Decrypt   each $A_i$ to get $a_i  \cdot G$.
	\item Use brute force to find $a$.\footnote{One can use    processing to speed-up this part from $c$ group operations to $\sqrt{c}$  operations, or even \Inote{cite} to   $\sqrt[3]{c}$.}
	
	\item Reconstruct $a$.
\end{enumerate}
In \cref{sec:ChanksEg:Eg}, we formally define the  ElGamal in-the-exponent scheme, and a few ZK proofs for the \NP-relations the scheme induces. Actually, we use a ``twisted'' variant of this scheme, that supports somewhat more efficient proofs in our settings.   The chunk ElGamal  scheme is defined in \cref{sec:ChanksEg:EgScheme}, and the related ZK proofs are defined in \cref{sec:ChanksEg:Proofs}. Finally, in \cref{sec:ChanksEg:Adjusting} we explain  how to adjust \cref{prot:ConfidentialTransactions} to work with this almost homomorphic scheme.

\subsection{Twisted ElGamal In-the-Exponent Encryption Scheme}\label{sec:ChanksEg:Eg}
Throughout we fix a cyclic  additive $q$-size group $\cG$ with generator $G$. The  twisted ElGamal in-the-exponent encryption scheme $(\EgKG,\EgEnc,\EgDec)$ is defined below. Note that it  gets  $H\in \cG$ as an  additional parameter. The ciphertext of the encryption scheme are elements of $\cG \times \cG$. We will mark such  ciphertexts   using tilde, and  address  the left-hand side and right-hand side of such  a ciphertext $\tA$,  by $\tA_L$ and  $\tA_R$, respectively. 



\begin{algorithm}[$(\EgKG,\EgEnc,\EgDec)$: Twisted ElGamal in-the-exponent encryption]\label{alg:TEGinExp}~
	
	
	\item[Key generation:] $\EgKG(1^b,H)$ samples $e\getsr \Z_q$, and outputs $(\sk 
	\asn e,\pk \asn (1^b,H,E\asn  e^{-1}\cdot H))$.
	
	\item[Encryption:] $\EgEnc_{(H,E)}(a)$  samples $r\getsr \Z_q$, and outputs  $\tA  = (\tA _L,\tA _R)\asn (r\cdot E, \Ped_H(a;r))$, for 
	$\Ped_H(a;r) \eqdef r\cdot H + a \cdot G$.
	
	
	\item[Decryption:] $\EgDec_{(1^b,H,e)}(\tA)$,   
	\begin{enumerate}
		\item 	Let $M \asn \tA_R - e\cdot \tA_L$.
		
		\item Find (using brute force) $m\in (-b, b) \in \Z_q$ so that $m\cdot G = M$. Abort if no such $m$ exists.
		
		\item Output $m$.
	\end{enumerate}
	
	\item[Addition:] Addition over  $\cG^2$.\footnote{For $\tA,\tB \in \cG^2$: $\tA +\tB \eqdef (\tA_L+\tB_L,\tA_R+\tB_R)$.}
	
	\item[Minus:]  The inverse in $\cG^2$.
	
\end{algorithm}	
When clear from the context,  will omit the parameters $1^b$ from the public key of the scheme.

Namely, the right hand side if a twisted ElGamal ciphertext is just a  Pedersen  commitment \cite{Pedersen91} (of the same palaintext). This change enable  using proofs that  support  Pedersen commitment on the ciphertext without changing it, but doing that  should be done with care.
\begin{enumerate}
	\item The parameter $H$ should be chosen so that the prover does not know that discrete log of $H$ \wrt $G$. (Otherwise, a proof of the Pedersen part means nothing).
	
	\item When using a proof of  the Pedersen part (which should always be POK, since Pedersen is perfectly hiding), it should \emph{always} be accompanied with a POK of the palaintext for the whole EG encryption (otherwise, the palaintext and randomness  extracted by the  Pedersen POK, might be  inconsistent with  EG publicj key)  
\end{enumerate}

\begin{theorem}[Security  of twisted-ElGamal in-the-exponent]\label{thm:tEGinExp}
	Assuming DDH is hard over $\cG$, then \cref{alg:tEGinExp} is  a perfectly binding,  semantically secure additively homomorphic scheme over $\Z_q$, with the following caveat:  the description only guaranteed to work on encryptions of explain in $(b)$,   for $1^b$ being the parameter  of the key generation algorithm:
\end{theorem}



\subsubsection{Zero-Knowledge Proofs}\label{sec:ChanksEg:Eg:ZK}

\Inote{Keeping the randomness  used to generate $\oA_s$,  leads to more effceint proof}

In \cref{sec:ChanksEg:EgScheme} we make use of ZK proofs for the following relations regrading the above scheme.  


\begin{description}
	\item[Knowledge of secret key.] ~
	
	
	
	\begin{description}
		\item[Task:] ZKPOK for $\rEgKeyGen = \rEgKeyGenDef$.
		
		\item[Protocol:] The standard Schnorr proof for discrete log \cite{Shoup00b}.
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for 
		
		$\rEgEnc=\rEgEncDef$.
		
		\item[Protocol:]   \cite[Protocol A.2]{HaitnerLNR23}.
		
	%	$$\rPedEnc = \rPedEncDef $$
	%	Namely, the proof is only applied to  $\tA_1$, \ie the right hand side of the ciphertext. 
		
	\end{description}
	
	
	\item[Equality using randomness.] 

	
	
	\begin{description}
		\item[Task:] ZKP for  $\rEgEq =\rEgEqDef$.
		
		
		Namely, the relation  is of  ciphertexts that encrypt the  same value under the different  public key, where the witness  is the plaintext and the two randomness used by the encryption algorithm.
		
		\item[Proof:] The Sigma protocol for this relation concatenates, with the same challenge $t$, two proofs of $\rEgEnc$. 

\item[Proof for the case $E_0=E_1$:] For this case, the proof is somewhat simpler. \Pc proves that $\tB \asn \tA_1 - \tA_0$ is an encryption of $0$ under $E$. Specifically, that it knows $r$ (\ie $r\asn r_1 -r_0$) so that  $\tB  = r\cdot (E,H)$. The Sigma protocol for this relation concatenates, with the same challenge $t$, two discrete log proofs. (Thus, prover only sends two group elements, vs four above.)

        		
\end{description}


\item[Equality using secret key.]~




\begin{description}
	\item[Task:] ZKP for 
	
	 $\rEgEqWr =\rEgEqWrDef$.
	
	
	letting   $\wEgDec_e (\tA) \eqdef \tA_1- e\cdot \tA_0$. 
	
	Namely, the relation  is of  ciphertexts that encrypt the  same value under the same public key. The witness is the secret key.
	
	\item[Proof:] \Pc proves that $\tB \asn \tA_1 - \tA_0$ is an encryption of $0$ under $E$. Specifically, that it knows $e$ so that  $e\cdot \tB_R  = \tB_L$. This is just the standard Schnorr proof for discrete log.
	
\end{description}

	\item[In range.] ~
	\begin{description}
		\item[Task:] ZKP for $\rEgRp =\rEgRpDef$.
		
		\item[Protocol:]  The proof consists of two parts:
		\begin{enumerate}
			\item  \textit{Bullet proofs} \cite{SP:BBBPWM18}  (which is  ZKPOK) on $\tA_1$ (\ie right hand side of $\tA$).   
			
			
			
			\item   $\rEgEnc$ ZKPOK  for the whole $\tA$.
		\end{enumerate}
		
	\end{description}

\end{description}



\begin{remark}[Efficiency]
	The saving in the above proofs comparing to using non twisted EG, is in not sending two additional   group elements in the In-range proofs;  we do not have to provide the Pedersen commitment (one group element)  for the plain text and prove it is consistent with the EG encryption (three group elements). Yet, we still have to preform an EG POK proof (two group elements).
\end{remark}	

	
\subsubsection{Threshold Encryption Variant}\label{sec:ChanksEg:Eg:Tsh}	

\Inote{TODO}
\subsection{The Chunk-ElGamal  Scheme}\label{sec:ChanksEg:EgScheme}
In the following we fix $t,c\in \N$ with $t\le q$ and $\ell \asn t/c \in \N$. The chunk ElGamal encryption scheme  is defined as follows:



\begin{definition}[Base factorization]\label{def:basefactor}
For $a\in \Z_q$ let $a_0,\ldots,a_{\ell-1}$ so that $a =  \sum_{i \in (\ell)}    2^{i c} \cdot a_i$.
\end{definition}


\begin{algorithm}[$(\KeyGen,\Enc,\Dec)$: Chunk ElGamal adaptively homomorphic encryption]\label{alg:ChunkEGa}~
	
	\item[Key generation:] $\KeyGen(1^b,H)$: act as $\EgKG(1^b,H)$.
	
	\item[Encryiption:] $\Enc_\pk(a)$
	
	\begin{enumerate}
		\item Compute $(a_0,\ldots,a_{\ell-1}) \asn \basefactor(a)$.
		
		\item For each $i\in (\ell)$: let $\tA_i \getsr \EgEnc_\pk(a_i)$.
		
		\item Output $\oA \asn (\tA_0,\ldots, \tA_{\ell-1})$.
		
	\end{enumerate}
	 
	\item[Decription:] $\Dec_\sk(\oM,b)$   
	\begin{enumerate}
		\item 	 For each $i\in (\ell)$: let $m_i \getsr \EgDec_\sk(\oM_i,b)$.
		
		\item Let  $m \asn \sum_{i \in (\ell)}   2^{i c} \cdot  m_i $.
		
		\item Output $m$.
	\end{enumerate}
	
	\item[Addition:] Vector addition.\footnote{For $\oA,\oB \in (\cG^2)^\ell$, $\oA +\oB \eqdef (\tA_0+\tB_0,\ldots,\tA_{\ell-1}+\tB_{\ell-1})$.}
	
	\item[Minus:]  Vector negation.
	                     
	
\end{algorithm}


\begin{theorem}[Security  of Chunk ElGamal]\label{thm:ChunkEG}
	Assuming \DDH is hard over $\cG$, then \cref{alg:ChunkEGa} is  a perfectly binding,  semantically secure additively homophobic scheme over $\Z_q$, with the following caveat work on encryptions of plaintext  $a$ so that $\basefactor(a)\in (-b,b)^\ell$ ($1^b$ being the input of the key generation algorithm).
\end{theorem}


\subsection{Zero-Knowledge  Proofs }\label{sec:ChanksEg:Proofs}
In this section, we define the ZK and POK proofs used in  \cref{sec:MainProtocol}.
In the following, we omit the parameter $b$ from the input list of  \Dec.  We will address its value in \cref{sec:ChanksEg:Adjusting}.


\begin{description}
	\item[Knowledge of secret key.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for $\rKeyGen=\rKeyGenDef$.
		
		\item[Protocol:] Same as \piZKPOK{\rEgKeyGen}. 
		
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	

	\begin{description}
		\item[Task:] ZKPOK for $\rEnc=\rEncDef$.
		
		\item[Protocol:]~
		
		\begin{description}
			\item[\Pc:] On  input  $((\pk,\oA),(\oa,\orr)$.
			\begin{enumerate}
				\item For each $i\in (\ell)$: let  $\pi_i \asn \piZKPOK{\rEgEnc}((\pk,\oA_i),(\oa_i,\orr_i))$. 
				
				\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
				
			\end{enumerate}
			
			
			\item[\Vc:] On  input  $((\pk,\oA),\pi = (\pi_0,\ldots, \pi_{\ell-1}))$: Accept iff  $\vZK{\rEgEnc}((\pk,\tA_i), \pi_i)$ for all $i\in (\ell)$.
			
		\end{description} 
		
		
	\end{description}
	
	\begin{proof}
		Immediate.
	\end{proof}
	
\item[Equality.]~ 

\begin{description}
	\item[Task:] ZKP for $\rEq =\rEqDef$.
	
	\item[Protocol:]~
	
	\begin{description}
		
	\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(e_0,\orr_1))$: 
	

	\begin{enumerate}
		
		\item Let  $a \asn  \sum_{i\in (\ell)}    2^c \cdot \oa_i$. 
		
		\item For both $j\in \zo$:  $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
		
		  
		\item    $r_1 \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_1)_i$. 
			
		 
		\item Output $\pi \asn \pZK{\rEgEq}((\pk,\tA_0,\tA_1), (e_0,r_1))$.
				 
	\end{enumerate}
	
	\item[\Vc:] On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi)$: 
	
	\begin{enumerate}
		\item Generate $\tA_0$ and  $\tA_1$ as done by \Pc.
		
	\item Apply $\vZK{\rEgEq}((\pk,\tA_0,\tA_1), \pi)$.
	
	\end{enumerate}
\end{description}
	\end{description}
		

\begin{proof}
	\Inote{TODO}
\end{proof}
  



\item[In range.]~  

\begin{description}
	\item[Task:] ZK for $\rRp =\rRpDef$.
	
	\item[Protocol:]~
	
	\begin{description}
	\item[\Pc:] On input $((\pk,\oA,b),(\oa,\orr))$:
	
	\begin{enumerate}
			\item   $a \asn  \sum_{i\in (\ell)}   2^c \cdot \oa_i$. 
		\item    $\tA \asn  \sum_{i\in (\ell)}    2^c \cdot \oA_i$. 
		\item    $r \asn  \sum_{i\in (\ell)}  2^c \cdot \orr_i$. 
        
        \item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,b), (a,r))$.
        
	\end{enumerate}
	
	
\item[\Vc:] On input $((\pk,\oA,b),\pi)$:
	
	\begin{enumerate}
		\item   Generate $\tA$ as by \Pc.
		\item  Output $\vZK{\rEgRp}((\pk,\tA,b), \pi)$.
		
	\end{enumerate}
	
\end{description}
\end{description}

		\begin{proof}
			\Inote{TODO}
		\end{proof}
\item[In range using sceret key.]~  

\begin{description}
	\item[Task:] POK for $\rRpSk =\rRpSkDef$.
	
	
	\item[Protocol:] Similar line to the protocol for $\rRp$, but  the prover encrypt the value in $\tA$ using  fresh randomness (that it kn0es) and continue as above.
	
	
	\begin{description}
		\item[\Pc:] On input $((\pk,\oA,b),e)$:
		
		\begin{enumerate}
			\item   $a \asn  \sum_{i\in (\ell)}   2^c \cdot \oa_i$. 
			\item    $\tA \asn  \sum_{i\in (\ell)}    2^c \cdot \oA_i$. 
			\item    $r \asn  \sum_{i\in (\ell)}  2^c \cdot \orr_i$. 
			
			\item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,b), (a,r))$.
			
		\end{enumerate}
		
		
		\item[\Vc:] On input $((\pk,\oA,b),\pi)$:
		
		\begin{enumerate}
			\item   Generate $\tA$ as by \Pc.
			\item  Output $\vZK{\rEgRp}((\pk,\tA,b), \pi)$.
			
		\end{enumerate}
		
	\end{description}

	
\end{description}
	
\item[Freshness.]  ~
Proving that each of the entries of the  ciphertext are small. 

\begin{description}
	\item[Task:] ZKP for $\rtFsh =\rtFshDef$.

\item[Protocol:]~

\begin{description}	
	\item[\Pc:] On  input  $((\pk,\oA,b),(\oa,\orr)$:
	
	\begin{enumerate}
		\item For each $i\in (\ell)$: $\pi_i \asn \pZK{\rEgRp}((\pk,\tA_i,b), (\oa_i,\orr_i))$.
		\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
	\end{enumerate}
	 
	 
	 	\item[\Vc:] On  input  $((\pk,\oA,b), \pi= (\pi_0,\ldots, \pi_{\ell-1}))$: Accept iff  $\vZK{\rEgRp}((\pk,\tA_i,b), \pi_i)$ for all $i\in (\ell)$.
	 
	 
\end{description}

\end{description}

\begin{proof}
	\Inote{TODO}
\end{proof}
\end{description}


\subsection{Adjusting  \cref{prot:ConfidentialTransactions}}\label{sec:ChanksEg:Adjusting}
Since the decryption procedure of of chunk-ElGamal  encryption scheme only guarantees to work on certain type of ciphertexts, see \cref{thm:ChunkEG} and take a group element, \ie $H$, as an additional parameter,  instantiating \cref{prot:ConfidentialTransactions} with this scheme  requires some adjustments.

\begin{enumerate}
	
	\item[Init:] 
	\begin{enumerate}
		\item The parties  call an ideal functionality that returns $H \getsr \cG$.\footnotetext{Can be implemented using a proper protocol, ot sampled by a trusted  setup.}
		  
		\item 	Each $\Uc_i$ sets the parameters of the encryption key generation algorithm to $(1^b,H)$, for  $b \asn 2^{c}\cdot \pcount$.

	\end{enumerate}
 
	\item[Transfer.]  The sender also provide proofs that $X_d$ is fresh (\ie using \pZK{\rtFsh} with parameter $b\asn 2^c$).
	
	
	\item[Rollover:] The rollover over operation should be updated to allow the account holder to ``normalize''  its active balance: to make it fresh. Specifically
	
	\begin{enumerate}
		\item $\Uc_i$:
		
		\begin{enumerate}
			\item Decrypt $\oP_i$ and $\oB_i$ to get value $(p_i,r_i)$ and $(b_i,w_i)$ respectively.
			
			
			\item Generate a fresh  encryption $\oB_i'$ of $(p_i +b_i )$ and $\oP_i'$ of $0$.
			
			\item Generate a proof $\pi_\Eqs$ (\ie using \pZK{\rEq})   that $\oP_i+\oB_i = \oP_i'+ \oB_i'$.
			
			
		%	\item  Generate proofs $\pi^P_\Fshs$ and $\pi^B_\Fshs$ (\ie using \pZK{\rtFsh})   that $\oP_i'$ and $\oB_i'$ are fresh.
			
			\item Send $(\oP_i',\oB_i',\pi_\Eqs,\pi^P_\FshS,\pi^B_\FshS)$ to \Cc.
		%
			\item Send $(\oP_i',\oB_i',\pi_\Eqs)$ to \Cc.
		
		
		\end{enumerate}
		
		\item $\Cc$:
			\begin{enumerate}
			%	\item Verify $\pi_\Eqs,\pi^P_\Fshs$ and $\pi^B_\Fshs$.
				
					\item Verify $\pi_\Eqs$.
				
				\item Set $\oP_i  \asn \oP_i'$  and $\oB_i  \asn \oB_i'$.
				
				\item Continue as in the original protocol.
			\end{enumerate}
		
	\end{enumerate}
\end{enumerate}


\subsection{Efficient Improvements}\label{sec:ChanksEg:EfficientImp}

\begin{enumerate}
	\item The bullet proofs used  in the In range and the freshness proofs can be batched. 
	
	\item The Schnorr proofs can be batched. In particular, the one performed in the different In-range proofs.  
\end{enumerate}