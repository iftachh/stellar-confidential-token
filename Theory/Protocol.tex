
\newcommand{\init}{\mathsf{init}}
\newcommand{\issue}{\mathsf{issue}}
\newcommand{\transfer}{\mathsf{transfer}}
\newcommand{\audit}{\mathsf{audit}}
\newcommand{\rollover}{\mathsf{rollover}}
\newcommand{\withraw}{\mathsf{withraw}}
\newcommand{\history}{\mathsf{history}}
\newcommand{\balance}{\mathsf{avlBlance}}
\newcommand{\pendbalance}{\mathsf{pndBalance}}
\newcommand{\tcount}{\mathsf{tcount}}

\newcommand{\historylog}{\mathsf{log}}
\newcommand{\sConfTran}{\mathsf{ConfTrans}}
\newcommand{\pluseq}{\mathrel{+}=}
\newcommand{\minuseq}{\mathrel{-}=}
\newcommand{\unioneq}{\mathrel{\cup}=}

\newcommand{\fConfTran}{\MathAlgX{\cF_\sConfTran}}
\newcommand{\pConfTran}{\MathAlgX{\Pi_\sConfTran}}

\newcommand{\largest}{{\mathsf{lrg}}}
\newcommand{\posvst}{{\mathsf{pos}}}
\newcommand{\tempst}{{\mathsf{tmp}}}

\newcommand{\Issuer}{{\MathAlgX{Iss}}}
\newcommand{\Chain}{{\MathAlgX{C}}}
\newcommand{\pcount}{p_{\mathsf{pcount}} }
\newcommand{\psize}{p_{\mathsf{size}} }




\newcommand{\rEnc}{{\cR_{\sf Enc}}}
\newcommand{\rEncDef}
{
	\set{((\pk,A),(a,r))\colon \Enc_\pk(a;r)= A}
}

\newcommand{\rKeyGen}{{\cR_{\sf KeyGen}}}

\newcommand{\rKeyGenDef}
{
	\set{(\pk,w))\colon \KeyGen(w)= (\cdot,\pk)}
}




\newcommand{\Eqs}{{\sf Eq}}
\newcommand{\rEq}{\cR_\Eqs}

\newcommand{\rEqDef}
{
	\set{((\pk_0,\pk_1,\oA_0,\oA_1),(a,r_0,r_1))\colon \forall i\in \zo \; \Enc_{\pk_i}(a;r_i)= \A_i}
}


\newcommand{\RPs}{{\sf Rp}}
\newcommand{\rRp}{\cR_\RPs}

\newcommand{\rRpDef}
{
	\set{((\pk,\oA,b),(a,r))\colon \Enc_\pk(a;r)= \oA \sland a\in (b)}
}


\newcommand{\LrgEqs}{{\sf LrgerEq}}
\newcommand{\rLrgEq}{\cR_\LrgEqs}

\newcommand{\rLrgEqDef}
{
	\set{((\pk,\oA_0,\oA_1),(a_0,r_0,a_1,r_1))\colon \forall i\in \zo \; \Enc_\pk(a_i;r_i)= \oA_i \sland a_1 -a_0 \in (q)} 
}


\section{The Confidential Transaction Protocol}\label{sec:MainProtocol}




\subsection{The Ideal Functionality}\label{sec:MainProtocol:Ideal}


\begin{functionality}[\fConfTran: Confidential transactions]\label{func:ConfidentialTransactions}~
	
	
	
	\item[Parties:]	Issuer \Ic, chain holder  \Cc and users  $\Uc_1, 
	\ldots,\Uc_n$.
	
	
	\item[Parameters:] $\pcount,\psize,q \in \N$.
	
	
	\begin{description}
		\item[Init.] Upon receiving $\init$ from  all parties: 
		\begin{enumerate}
			\item  For each $i\in [n]$:  $\balance_i,\pendbalance_i \asn 0$, $\tcount_i \asn 0$, and  $\historylog_i \asn \emptyset$.
			
			\item  $\historylog \asn \emptyset$.
		\end{enumerate}
		
			\item[Issue.]   Upon receiving $(\sid,\issue,x,d)$ from  \Cc and \Ic:
		\begin{enumerate}
			
			
			\item \Assert{$x\in (\psize)$, $\tcount_d\le  \pcount$ and $d\in [n]$}.
			
			\item $\tcount_d^{++}$.
			
			\item $\pendbalance_d \pluseq x$.
			
			\item Set $\historylog \unioneq {(\sid,\issue,d,x,\tcount_d)}$.
		\end{enumerate}
		
		
		\item[Transfer.]    Upon receiving  $(\sid,\transfer,d)$ from  \Cc and  $\Uc_s$, with  $\Uc_s$ using private input $x$. 
		
	
		\begin{enumerate}
			\item \Assert{$x\in (\pcount)$, $\tcount\le  \psize$, $\balance_s  \ge x$ and $d \in [n]$}.
			
				\item $\tcount^{++}$.
				
				
			\item $\balance_s \minuseq x$.
			
			\item   $\pendbalance_d \unioneq x$.
			
			\item Set $\historylog_d \unioneq {(\sid,\transfer,s,x)}$
			
			\item Set $\historylog \unioneq {(\sid,\transfer,s,d)}$
			
		\end{enumerate}
		
		\item[Rollover.]     Upon receiving $(\sid,\rollover)$ from  party $\Uc_i$ and \Cc,  party \Cc
		
		\begin{enumerate}
			
			
			\item $\tcount \asn 0$.
			
			
			\item Set $\balance_i  \pluseq \pendbalance_i$.
			
			\item Set $\pendbalance_i  \asn 0$.
			
			\item Set $\historylog \unioneq (\sid,\rollover,i)$
			
			
		\end{enumerate}

		
			\item[Withraw.]     Upon receiving $(\sid,\withraw,x)$ from  party $\Uc_i$ and \Cc,  party \Cc
		
		\begin{enumerate}
			
			
			 \item \Assert{$x\in \N$, $\balance_i  \ge x$ and $i \in [n]$}.
			
			\item $\balance_i \minuseq x$.
			
			
			\item Set $\historylog \unioneq {(\sid,\withraw,i,x)}$
			
			
		\end{enumerate}
		
		
		\item[History.]     Upon receiving $(\sid,\history)$ from  party $\Uc_i$ and \Cc:  
		
		Send $(\historylog,\historylog_i)$ to  $\Uc_i$.	 
		
		\item[Audit.]      \Inote{TODO}
		
	\end{description}

\end{functionality}


\subsection{The Protocol}\label{sec:MainProtocol:Protocol}
Throughout, we fix a security parameter $\kappa$ and omit is from the notation. We also fix an homomorphic encryption scheme $(\KeyGen,\Enc,\Dec)$ over $\Z_q$ with randomness domain $\cD$.  We require that $\Dec_{sk}(\oA)$ outputs   $(a;r)$ such that $\oA = \Enc(a;r)$.

\paragraph{Main protocol.}
We split  the protocol into several sub-protocols defined below, and  use the  following environment to define the common part the different sub-protocols share, \eg global parameter. 

\begin{protocol}[\pConfTran: Confidential transactions]~\label{prot:ConfidentialTransactions}


	
\item[Parties:] Issuer \Ic, chain-holder \Cc and users  $\Uc_1, \ldots,\Uc_n$.

\item[Parameters:] $\pcount,\psize,q \in \N$.

\item[Subprotocols:]  See below.
\end{protocol}


\paragraph{Init.}
This sub-protocol is were the encryption key are sampled and shared, and the chain manager \Cc set the initial values of the chain. The protocol  uses ZKPOK proof for the relation:
\begin{description}
	\item[Key generation:]    $\rKeyGen =\rKeyGenDef$.
\end{description}


\begin{protocol}[\pConfTran.Init]~\label{prot:ConfidentialTransactions:Init}
	

	\item[Participating parties.] All parties.
			
			
	\item[Proofs:]   \piZKPOK{\rKeyGen}. 
	
	
	\item[Algorithms:]    \KeyGen.
	
			
\item[Operation:] ~
			
			
			\begin{enumerate}
				
				\item   $\Uc_i$, for  all $i\in [n]$:
				\begin{enumerate}
					\item Set $(pk_i,sk_i) \getsr \KeyGen(r_i)$ for $r_i \getsr \cD$.
					
					\item Store $sk_i$.
					
					\item Let $\pi_i \getsr \pZKPOK{\rKeyGen}(pk_i,r_i)$.
					
					\item Send $(pk_i,\pi_i)$ to \Cc.
					
					
				\end{enumerate}
				
				\item \Cc:
				\begin{enumerate}
					
					\item Call $\sset{ \vZKPOK{\rKeyGen}(pk_i,\pi_i)}_{i\in [n]}$. Abort and publish $i$, if the \ith  proof is not verified. 
										
					\item Store $\set{pk_i}_{i\in [n]}$.
				\end{enumerate}
				
				
				\item \Cc: 
				\begin{enumerate}
					\item 	Broadcast $\sset{\oP_i\getsr \Enc_{pk_i}(0),\oB_i\asn \Enc_{pk_i}(0),\tcount_i 
					\asn 0}_{i\in [n]}$.
					
					\item    Broadcast $\historylog \asn \emptyset$.
				\end{enumerate}								
			\end{enumerate}
\end{protocol}

\paragraph{Issue.}
\begin{protocol}[\pConfTran.Issue]~\label{prot:ConfidentialTransactions:Issue}
	\item[Participating parties.] \Ic and \Cc.
	
	
	
	\item[Common input.] $\sid$, $x\in \N$ and $d\in [n]$.
	
	\item[Operation:]  \Cc~
	
		\item \Cc:  
		\begin{enumerate}
			\item \Assert{$x\in [\psize]$ and $\tcount_d  \le \pcount$}
			
			\item Set $\oP_i \pluseq \Enc_{pk_i}(x))$.
				
		\item Broadcast $\historylog \unioneq (\sid,\issue,d,x,\oP_i,\tcount_d)$.
				 	
		
	\end{enumerate}
\end{protocol}

\paragraph{Transfer.}

The protocol uses ZK and ZKPOK proofs for the   following  relations:

\begin{description}
	\item[In range.] $\rRp =\rRpDef$, \ie  encryption of values in $[\psize]$.
	
	\item[Equality.] $\rEq =\rEqDef$, \ie  encryptions of the same pair under different public keys.
	
	\item[Larger than.] $\rLrgEq =\rLrgEqDef$, \ie encryptions of the  pair of values $(a_0,a_1)$, under the same public key, with $a_1 \ge a_0$.
\end{description}




\begin{protocol}[\pConfTran.Transfer]~\label{prot:ConfidentialTransactions:Transfer}
	\item[Participating parties:] $\Uc_s$ and \Cc.
	
\item[Proofs:]   \piZK{\rRp},\pZK{\rEq},\pZK{\rLrgEq}


\item[Algorithms:]    \Dec.

	
	\item[Common input:] $d\in [n]$.
	
	\item[$\Uc_s$'s private  input.] $x \in \N$.
	
\item[Operation:] ~
	
	\begin{enumerate}
		\item  $\Uc_s$: 
		
		\begin{enumerate}
			\item $X_d \getsr \Enc_{\pk_d}(x;r)$ for $r^d \getsr \cD$.
			
		
			\item $\pi^\RPs \getsr \pZK{\rRp}((\pk_d,X_s,\psize),(x,r))$.
			
			
			\item $X_s \getsr \Enc_{\pk_s}(x;r)$ for $r^s \getsr \cD$.
			
			
			
			\item $\pi^\Eqs \getsr \pZK{\rEq}((\pk_s,\pk_d,X_s,X_s),(x,r_s,r_d))$.
			
			
			\item $(b,r^b) \asn \Dec_{sk_s}(\oB_s)$.
			
			
			\item $\pi^\LrgEqs \getsr \pZK{\rLrgEq}((\pk_s,X_s,\oB_s),(x,r_s,r_b))$.
			
			
			\item Send $(X_s,X_d,\pi^\RPs,\pi^\Eqs,\pi^\LrgEqs)$ to \Cc.
		\end{enumerate}
		
		
		\item  \Cc: 
		
		\begin{enumerate}
			\item  Call $\vZKPOK{\rRp}((\pk_d,X_s,\psize),\pi^\RPs)$,
			
			 $\vZKPOK{\Eqs}((\pk_s,\pk_d,X_s,X_s),\pi^\RPs)$ and $\vZKPOK{\rLrgEq}((\pk_s,X_s,\oB_s),\pi^\RPs)$.
			
		\item Verify $\tcount_d \le \pcount$.
		
		
		     \item  Set $U_s \minuseq X_s$. 
              
              \item  Set $\oP_d \pluseq X_d$. 
              
              \item $\tcount_d^{++}$.
              
		     \item Publish  $\historylog \unioneq (\sid,\transfer,s,d,U_s,\oP_d)$.
		     
		\end{enumerate}
		
	\end{enumerate}
	
\end{protocol}



\paragraph{Rollover.}

\begin{protocol}[\pConfTran.Rollover]~\label{prot:ConfidentialTransactions:Rollover}
	\item[Participating parties.] $\Uc_i$ and \Cc.
	
\item[Operation:] \Cc:
	
	\begin{enumerate}
	
	\item $\oB_i  \pluseq \oP_i$.
	
	
	\item  $\oP_i \minuseq \oP_i$.
	
	\item Set $\tcount_i \asn 0$.
	
	
	\item  $\historylog \pluseq (\sid,\rollover,i,\oB_i,\oP_i)$
	
	
\end{enumerate}
	
\end{protocol}


\paragraph{History.}

\begin{protocol}[\pConfTran.History]~\label{prot:ConfidentialTransactions:History}
	\item[Participating parties.] $\Uc_i$ and \Cc.
		
	\item Operation: \Cc: send  $\historylog$ to $\Uc_i$.
	
\end{protocol}


\paragraph{Audit.} \Inote{TODO}


\subsection{Security of \cref{prot:ConfidentialTransactions}}
\begin{theorem}[Security of \cref{prot:ConfidentialTransactions}]\label{thm:ConfidentialTransactions}
Assuming  $(\KeyGen,\Enc,\Dec)$ is CPA secure, then \cref{prot:ConfidentialTransactions} UC-realizes \cref{func:ConfidentialTransactions}.
\end{theorem}

\begin{proof}
\Inote{TODO}
\end{proof}

