\section{The Confidential Transaction Protocols}\label{sec:MainProtocol}


\newcommand{\init}{\mathsf{init}}
\newcommand{\issue}{\mathsf{issue}}
\newcommand{\transfer}{\mathsf{transfer}}
\newcommand{\audit}{\mathsf{audit}}
\newcommand{\rollover}{\mathsf{rollover}}
\newcommand{\withraw}{\mathsf{withraw}}
\newcommand{\history}{\mathsf{history}}
\newcommand{\balance}{\mathsf{avlBlance}}
\newcommand{\pendbalance}{\mathsf{pndBalance}}
\newcommand{\transactionnum}{\mathsf{transnum}}

\newcommand{\historylog}{\mathsf{log}}
\newcommand{\sConfTran}{\mathsf{ConfTrans}}
\newcommand{\pluseq}{\mathrel{+}=}
\newcommand{\minuseq}{\mathrel{-}=}
\newcommand{\unioneq}{\mathrel{\cup}=}

\newcommand{\fConfTran}{\MathAlgX{\cF_\sConfTran}}
\newcommand{\pConfTran}{\MathAlgX{\Pi_\sConfTran}}

\newcommand{\largest}{{\mathsf{lrg}}}
\newcommand{\posvst}{{\mathsf{pos}}}
\newcommand{\tempst}{{\mathsf{tmp}}}

\newcommand{\Issuer}{{\MathAlgX{Iss}}}
\newcommand{\Chain}{{\MathAlgX{C}}}
\newcommand{\pnum}{p_{\mathsf{num}} }
\newcommand{\psize}{p_{\mathsf{size}} }


\subsection{The Ideal Functionality}\label{sec:MainProtocol:Ideal}


\begin{functionality}[\fConfTran: Confidential transactions]\label{func:ConfidentialTransactions}~
	
	
	
	\item[Parties:]	Issuer \Ic, chain holder  \Cc and users  $\Uc_1, 
	\ldots,\Uc_n$.
	
	
	\item[Parameters:] $\pnum,\psize \in \N$.
	
	
	\begin{description}
		\item[Init.] Upon receiving $\init$ from  all parties: 
		\begin{enumerate}
			\item  For each $i\in [n]$:  $\balance_i,\pendbalance_i \asn 0$, $\transactionnum_i \asn 0$, and  $\historylog_i \asn \emptyset$.
			
			\item  $\historylog \asn \emptyset$.
		\end{enumerate}
		
			\item[Issue.]   Upon receiving $(\sid,\issue,x,d)$ from  \Cc and \Ic:
		\begin{enumerate}
			
			
			\item \Assert{$x\in (\pnum)$, $\transactionnum\le  \psize$ and $d\in [n]$}.
			
			\item $\transactionnum^{++}$.
			
			\item $\pendbalance_d \pluseq x$.
			
			\item Set $\historylog \unioneq {(\sid,\issue,x,d)}$.
		\end{enumerate}
		
		
		\item[Transfer.]    Upon receiving  $(\sid,\transfer,d)$ from  \Cc and  $\Uc_s$, with  $\Uc_s$ using private input $x$. 
		
	
		\begin{enumerate}
			\item \Assert{$x\in (\pnum)$, $\transactionnum\le  \psize$, $\balance_s  \ge x$ and $d \in [n]$}.
			
				\item $\transactionnum^{++}$.
				
				
			\item $\balance_s \minuseq x$.
			
			\item   $\pendbalance_d \unioneq x$.
			
			\item Set $\historylog_d \unioneq {(\sid,\transfer,s,x)}$
			
			\item Set $\historylog \unioneq {(\sid,\transfer,s,d)}$
			
		\end{enumerate}
		
		\item[Rollover.]     Upon receiving $(\sid,\rollover)$ from  party $\Uc_i$ and \Cc,  party \Cc
		
		\begin{enumerate}
			
			
			\item $\transactionnum \asn 0$.
			
			
			\item Set $\balance_i  \pluseq \pendbalance_i$.
			
			\item Set $\pendbalance_i  \asn 0$.
			
			\item Set $\historylog \unioneq (\sid,\rollover,i)$
			
			
		\end{enumerate}

		
			\item[Withraw.]     Upon receiving $(\sid,\withraw,x)$ from  party $\Uc_i$ and \Cc,  party \Cc
		
		\begin{enumerate}
			
			
			 \item \Assert{$x\in \N$, $\balance_i  \ge x$ and $i \in [n]$}.
			
			\item $\balance_i \minuseq x$.
			
			
			\item Set $\historylog \unioneq {(\sid,\withraw,i,x)}$
			
			
		\end{enumerate}
		
		
		\item[History.]     Upon receiving $(\sid,\history)$ from  party $\Pc_i$ and \Cc:  
		
		Send $(\historylog,\historylog_i)$ to  $\Pc_i$.	 
		
		\item[Audit.]      \Inote{Later}
		
	\end{description}

\end{functionality}


\subsection{The Protocol}\label{sec:MainProtocol:Protocol}
Throughout, we fix a security parameter $\kappa$ and omit is from the notation. We also fix an homomorphic encryption scheme $(\KeyGen,\Enc,\Dec)$ over $\Z_q$ with randomness domain $\cD$.  We require that $\Dec_{sk}(\oA)$ outputs   $(a;r)$ such that $\oA = \Enc(a;r)$.


\begin{protocol}[\pConfTran: Confidential transactions]~\label{prot:ConfidentialTransactions}


	
\item[Parties:] Issuer \Ic, chain-holder \Cc and users  $\Uc_1, \ldots,\Uc_n$.


\item[Subprotocols:]  See below.
\end{protocol}


\paragraph{Init.}
\newcommand{\rKeyGen}{{\cR_{\sf KeyGen}}}

\newcommand{\rKeyGenDef}
{
	 \set{(pk,w))\colon \KeyGen(w)= (\cdot,pk)}
}


We use the   of  key-generation relation  
$$\rKeyGen =\rKeyGenDef.$$

\begin{protocol}[\pConfTran.Init]~\label{prot:ConfidentialTransactions:Init}
	

	\item[Participating parties.] All parties.
			
			
	\item[Proofs:]   \piZKPOK{\rKeyGen}. 
	
	
	\item[Algorithms:]    \KeyGen.
	
			
\item[Operation:] ~
			
			
			\begin{enumerate}
				
				\item   $\Pc_i$, for  all $i\in [n]$:
				\begin{enumerate}
					\item Set $(pk_i,sk_i) \getsr \KeyGen(r_i)$ for $r_i \getsr \cD$.
					
					\item Store $sk_i$.
					
					\item Let $\pi_i \getsr \pZKPOK{\rKeyGen}(pk_i,r_i)$.
					
					\item Send $(pk_i,\pi_i)$ to \Cc.
					
					
				\end{enumerate}
				
				\item \Cc:
				\begin{enumerate}
					
					\item Call $\sset{ \vZKPOK{\rKeyGen}(pk_i,\pi_i)}_{i\in [n]}$. Abort and publish $i$, if the \ith  proof is not verified. 
										
					\item Store $\set{pk_i}_{i\in [n]}$.
				\end{enumerate}
				
				
				\item \Cc: 
				\begin{enumerate}
					\item 	Broadcast $\sset{\oP_i \asn 0, \oP_i\getsr \Enc_{pk_i}(0),\oB_i\asn \emptyset}_{i\in [n]}$.
					
					\item    Broadcast $\historylog \asn \emptyset$.
				\end{enumerate}								
			\end{enumerate}
\end{protocol}

\paragraph{Issue.}
\begin{protocol}[\pConfTran.Issue]~\label{prot:ConfidentialTransactions:Issue}
	\item[Participating parties.] \Ic and \Cc.
	
	
	\item[\Cc's input.] $\sid$, $x\in \N$ and $i\in [n]$.
	
	\item[Operation:] ~
	
	
	\begin{enumerate}
		
		\item   \Ic: Send $(x,i)$ to \Cc.
		
		\item \Cc:  
		\begin{enumerate}
			\item \Assert{$x\in [\psize]$ and $\oP_i  \le \psize$}
			
			\item Set $\oP_i \pluseq \Enc_{pk_i}(x))$.
				
		\item Publish $\historylog \unioneq (\sid,\issue,x,i,\oP_i)$.
				 	
		\end{enumerate}
		
	\end{enumerate}
\end{protocol}

\paragraph{Transfer.}

\newcommand{\RPs}{{\sf rp}}
\newcommand{\rRP}{\cR_\RPs}

\newcommand{\rRPDef}
{
	\set{((pk,A),(a,r))\colon \Enc_{pk}(a;r)= A \sland a\in [\psize]}
}


\newcommand{\Eqs}{{\sf eq}}
\newcommand{\rEQ}{\cR_\Eqs}

\newcommand{\rEQDef}
{
	\set{((pk_0,pk_1,A_0,A_1),(a,r_0,r_1))\colon \forall i\in \zo \; \Enc_{pk_i}(a;r_i)= A_i}
}

\newcommand{\Lrgs}{{\sf lrger}}
\newcommand{\rLrg}{\cR_\Lrgs}

\newcommand{\rLrgDef}
{
	\set{((pk,A_0,A_1),(a_0,r_0,a_1,r_1))\colon \forall i\in \zo \; \Enc_{pk}(a_i;r_i)= A_i \sland a_1 -a_0 \in [q]} 
}

We use proofs for the   following  relations  
$$\rRP =\rRPDef$$
I.e., encryption of values in $[\psize]$.
$$\rEQ =\rEQDef$$
I.e., encryptions of the same pair under different public keys.


$$\rLrg =\rLrgDef$$
I.e., encryptions of the  pair of values $(a_0,a_1)$, under the same public key, with $a_1 \ge a_0$.

\begin{protocol}[\pConfTran.Transfer]~\label{prot:ConfidentialTransactions:Transfer}
	\item[Participating parties:] $\Pc_s$ and \Cc.
	
\item[Proofs:]   \piZKPOK{\rRP},\pZKPOK{\rEQ},\pZKPOK{\rLrg}


\item[Algorithms:]    \Dec.

	
	\item[Common input:] $d\in [n]$.
	
	\item[$\Pc_s$'s private  input.] $x \in \N$.
	
\item[Operation:] ~
	
	\begin{enumerate}
		\item  $\Pc_s$: 
		
		\begin{enumerate}
			\item $X_d \getsr \Enc_{pk_d}(x;r)$ for $r^d \getsr \cD$.
			
		
			\item $\pi^\RPs \getsr \pZKPOK{\rRP}((pk_d,X_s,\psize),(x,r))$.
			
			
			\item $X_s \getsr \Enc_{pk_s}(x;r)$ for $r^s \getsr \cD$.
			
			
			
			\item $\pi^\Eqs \getsr \pZKPOK{\rEQ}((pk_s,pk_d,X_s,X_s),(x,r_s,r_d))$.
			
			
			\item $(b,r^b) \asn \Dec_{sk_s}(\oB_s)$.
			
			
			\item $\pi^\Lrgs \getsr \pZKPOK{\rLrg}((pk_s,X_s,\oB_s),(x,r_s,r_b))$.
			
			
			\item Send $(X_s,X_d,\pi^\RPs,\pi^\Eqs,\pi^\Lrgs)$ to \Cc.
		\end{enumerate}
		
		
		\item  \Cc: 
		
		\begin{enumerate}
			\item  Call $\vZKPOK{\rRP}((pk_d,X_s,\psize),\pi^\RPs)$,
			
			 $\vZKPOK{\Eqs}((pk_s,pk_d,X_s,X_s),\pi^\RPs)$ and $\vZKPOK{\rLrg}((pk_s,X_s,\oB_s),\pi^\RPs)$.
			
		
		     \item  Set $U_s \minuseq X_s$. 
              
              \item  Set $\oP_d \pluseq X_d$. 
              
              		     
		     \item Publish  $\historylog \unioneq (\sid,\transfer,s,d,U_s,\oP_d)$.
		     
		\end{enumerate}
		
	\end{enumerate}
	
\end{protocol}



\paragraph{Rollover.}

\begin{protocol}[\pConfTran.Rollover]~\label{prot:ConfidentialTransactions:Rollover}
	\item[Participating parties.] $\Pc_i$ and \Cc.
	
\item[Operation:] ~
	
	\Cc:
	
	\begin{enumerate}
	
	\item $\oB_i  \pluseq \\oP_i$.
	
	
	\item  $\oP_i \minuseq \oP_i$.
	
	\item  $\historylog \pluseq (\sid,\rollover,i,\oB_i,\oP_i)$
	
	
\end{enumerate}
	
\end{protocol}


\paragraph{History.}

\begin{protocol}[\pConfTran.History]~\label{prot:ConfidentialTransactions:History}
	\item[Participating parties.] $\Pc_i$ and \Cc.
		
	\item Operation: \Cc: send  $\historylog$ to $\Pc_i$.
	
\end{protocol}


\paragraph{Audit.} \Inote{TODO}


\subsubsection{Security of \cref{prot:ConfidentialTransactions}}
\begin{theorem}[Security of \cref{prot:ConfidentialTransactions}]\label{thm:ConfidentialTransactions}
\Inote{TODO}
\end{theorem}


